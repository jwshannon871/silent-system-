import os, time, json, threading, random, datetime, html
from pathlib import Path
from flask import Flask, Response

# -------------------------------
# Config
# -------------------------------
PORT = int(os.environ.get("PORT", 8080))
DATA_DIR = Path(os.environ.get("DATA_DIR", "data"))
DATA_DIR.mkdir(parents=True, exist_ok=True)

HARVEST_LOG = DATA_DIR / "harvest_log.jsonl"
OPTIMIZED_FEED = DATA_DIR / "optimized_feed.json"

HARVEST_INTERVAL_SEC = 60         # pull once per minute
OPTIMIZE_INTERVAL_SEC = 120       # rebuild feed every 2 minutes
MAX_ITEMS_IN_FEED = 50

# Public free endpoints (examples‚Äîexpand later)
ENDPOINTS = [
    "https://api.publicapis.org/entries",
    "https://catfact.ninja/fact",
    "https://dog.ceo/api/breeds/image/random"
]

# -------------------------------
# Harvest (Module 1)
# -------------------------------
import requests

def harvest_once():
    url = random.choice(ENDPOINTS)
    try:
        r = requests.get(url, timeout=12)
        payload = r.json() if r.ok else {"status": r.status_code, "text": r.text[:500]}
    except Exception as e:
        payload = {"error": str(e)}

    record = {
        "ts": datetime.datetime.utcnow().isoformat() + "Z",
        "source": url,
        "data": payload
    }
    with HARVEST_LOG.open("a", encoding="utf-8") as f:
        f.write(json.dumps(record, ensure_ascii=False) + "\n")

def harvester_loop():
    while True:
        harvest_once()
        time.sleep(HARVEST_INTERVAL_SEC)

# -------------------------------
# Optimize (Module 2)
# -------------------------------
def summarize(item: dict) -> str:
    # make a short, safe, human-visible snippet
    txt = json.dumps(item, ensure_ascii=False)
    txt = html.escape(txt)
    if len(txt) > 240:
        txt = txt[:240] + "..."
    return txt

def optimize_loop():
    while True:
        items = []
        if HARVEST_LOG.exists():
            with HARVEST_LOG.open("r", encoding="utf-8") as f:
                for line in f.readlines()[-400:]:  # last 400 records for input
                    try:
                        obj = json.loads(line)
                    except Exception:
                        obj = {"raw": line.strip()}
                    items.append(obj)

        # dedupe by source+data snapshot for variety
        seen = set()
        optimized = []
        for obj in reversed(items):  # newest first
            key = json.dumps({"s": obj.get("source"), "d": obj.get("data")}, sort_keys=True)
            if key in seen:
                continue
            seen.add(key)
            optimized.append({
                "ts": obj.get("ts"),
                "source": obj.get("source"),
                "snippet": summarize(obj.get("data"))
            })
            if len(optimized) >= MAX_ITEMS_IN_FEED:
                break
        optimized.reverse()  # oldest ‚Üí newest for display

        with OPTIMIZED_FEED.open("w", encoding="utf-8") as f:
            json.dump(optimized, f, indent=2, ensure_ascii=False)

        time.sleep(OPTIMIZE_INTERVAL_SEC)

# -------------------------------
# Web (Module 3)
# -------------------------------
APP_TITLE = "Automated Feed Hub"
ADSENSE_CLIENT = os.environ.get("ADSENSE_CLIENT", "")  # e.g. ca-pub-XXXXXXXXXXXXXXXX
AD_UNIT_BLOCK = """
<!-- Example Ad Unit (replace with your AdSense unit) -->
<ins class="adsbygoogle"
     style="display:block"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>(adsbygoogle = window.adsbygoogle || []).push({});</script>
"""

HTML_TEMPLATE = """<!doctype html>
<html>
<head>
  <meta charset="utf-8">
  <title>{title}</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  {adsense_script}
  <style>
    body {{ font-family: system-ui, Arial, sans-serif; max-width: 820px; margin: 0 auto; padding: 24px; }}
    .card {{ border: 1px solid #ddd; border-radius: 12px; padding: 12px 16px; margin: 12px 0; }}
    .ts {{ color:#666; font-size: 12px; }}
    .hdr {{ display:flex; align-items:center; gap:8px; }}
  </style>
</head>
<body>
  <div class="hdr">
    <h1 style="margin:0;">üåê {title}</h1>
    <div style="flex:1"></div>
    <small>auto-updating</small>
  </div>

  <p>Fresh content generated by an autonomous agent. Page refresh pulls the latest optimized feed.</p>

  {ad_block}

  <div id="feed">
    {feed_items}
  </div>

  <hr>
  <p><small>Powered by Agent Mode. Last build: {now} UTC</small></p>
</body>
</html>"""

def render_index():
    if OPTIMIZED_FEED.exists():
        try:
            data = json.loads(OPTIMIZED_FEED.read_text(encoding="utf-8"))
        except Exception:
            data = [{"snippet": "Feed parse error"}]
    else:
        data = [{"snippet": "No data yet ‚Äî harvesting has just started."}]

    items_html = []
    for entry in reversed(data):  # newest on top
        ts = html.escape(entry.get("ts") or "")
        src = html.escape(entry.get("source") or "")
        snip = entry.get("snippet") or ""
        items_html.append(
            f"<div class='card'><div class='ts'>{ts} ¬∑ {src}</div><div>{snip}</div></div>"
        )

    adsense_script = ""
    if ADSENSE_CLIENT:
        adsense_script = f'<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client={ADSENSE_CLIENT}" crossorigin="anonymous"></script>'

    page = HTML_TEMPLATE.format(
        title=APP_TITLE,
        adsense_script=adsense_script,
        ad_block=AD_UNIT_BLOCK if ADSENSE_CLIENT else "",
        feed_items="\n".join(items_html),
        now=datetime.datetime.utcnow().strftime("%Y-%m-%d %H:%M:%S")
    )
    return page

app = Flask(__name__)

@app.get("/")
def index():
    return Response(render_index(), mimetype="text/html")

def boot():
    # start background threads
    threading.Thread(target=harvester_loop, daemon=True).start()
    threading.Thread(target=optimize_loop, daemon=True).start()
    # start web server
    app.run(host="0.0.0.0", port=PORT, threaded=True)

if __name__ == "__main__":
    boot()
